(* generated by Ott 0.30, locally-nameless from: src/ott/DKDeclarative.ott *)
Require Import Bool.
Require Import Metalib.Metatheory.
Require Import List.
Require Import Ott.ott_list_core.
(** syntax *)
Definition tpvar : Set := var. (*r variables *)

Inductive type : Set :=  (*r types *)
 | t_var_b (_:nat) (*r variable *)
 | t_var_f (x:tpvar) (*r variable *)
 | t_int : type (*r integer type *)
 | t_all (A:type) (*r polymorphic types *)
 | t_arrow (A:type) (B:type) (*r function types *).

Definition dkcontext : Set := (list tpvar).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_type_wrt_type_rec (k:nat) (A5:type) (A_6:type) {struct A_6}: type :=
  match A_6 with
  | (t_var_b nat) => if (k === nat) then A5 else (t_var_b nat)
  | (t_var_f x) => t_var_f x
  | t_int => t_int 
  | (t_all A) => t_all (open_type_wrt_type_rec (S k) A5 A)
  | (t_arrow A B) => t_arrow (open_type_wrt_type_rec k A5 A) (open_type_wrt_type_rec k A5 B)
end.

Definition open_type_wrt_type A5 A_6 := open_type_wrt_type_rec 0 A_6 A5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_type *)
Inductive lc_type : type -> Prop :=    (* defn lc_type *)
 | lc_t_var_f : forall (x:tpvar),
     (lc_type (t_var_f x))
 | lc_t_int : 
     (lc_type t_int)
 | lc_t_all : forall (L:vars) (A:type),
      ( forall x , x \notin  L  -> lc_type  ( open_type_wrt_type A (t_var_f x) )  )  ->
     (lc_type (t_all A))
 | lc_t_arrow : forall (A B:type),
     (lc_type A) ->
     (lc_type B) ->
     (lc_type (t_arrow A B)).
(** free variables *)
Fixpoint fv_type (A5:type) : vars :=
  match A5 with
  | (t_var_b nat) => {}
  | (t_var_f x) => {{x}}
  | t_int => {}
  | (t_all A) => (fv_type A)
  | (t_arrow A B) => (fv_type A) \u (fv_type B)
end.

(** substitutions *)
Fixpoint subst_type (A5:type) (x5:tpvar) (A_6:type) {struct A_6} : type :=
  match A_6 with
  | (t_var_b nat) => t_var_b nat
  | (t_var_f x) => (if eq_var x x5 then A5 else (t_var_f x))
  | t_int => t_int 
  | (t_all A) => t_all (subst_type A5 x5 A)
  | (t_arrow A B) => t_arrow (subst_type A5 x5 A) (subst_type A5 x5 B)
end.

Fixpoint ctx_dom (c : list tpvar) :=
  match c with
  | nil => empty
  | x :: c' => add x (ctx_dom c')
  end
.


(** definitions *)

(* defns Monotype *)
Inductive dk_mono : type -> Prop :=    (* defn dk_mono *)
 | dkm_var : forall (x:tpvar),
     dk_mono (t_var_f x)
 | dkm_int : 
     dk_mono t_int
 | dkm_arrow : forall (A B:type),
     dk_mono A ->
     dk_mono B ->
     dk_mono (t_arrow A B).

(* defns WellformedContext *)
Inductive dk_wf_ctx : dkcontext -> Prop :=    (* defn dk_wf_ctx *)
 | wf_ctx_nil : 
     dk_wf_ctx  nil 
 | wf_ctx_cons : forall (G:dkcontext) (x:tpvar),
      dk_wf_ctx G  ->
      (not (In  x   G ))  ->
     dk_wf_ctx  ( x  ::  G ) .

(* defns WellformedType *)
Inductive dk_wf_tp : dkcontext -> type -> Prop :=    (* defn dk_wf_tp *)
 | wf_tp_var : forall (G:dkcontext) (x:tpvar),
      dk_wf_ctx G  ->
      (In  x   G )  ->
     dk_wf_tp G (t_var_f x)
 | wf_tp_int : forall (G:dkcontext),
     dk_wf_ctx G ->
     dk_wf_tp G t_int
 | wf_tp_arrow : forall (G:dkcontext) (A B:type),
      dk_wf_tp G A  ->
     dk_wf_tp G B ->
     dk_wf_tp G (t_arrow A B)
 | wf_tp_all : forall (L:vars) (G:dkcontext) (A:type),
      ( forall x , x \notin  L  -> dk_wf_tp  ( x  ::  G )   ( open_type_wrt_type A (t_var_f x) )  )  ->
     dk_wf_tp G (t_all A).

(* defns Subtyping *)
Inductive dk_sub : dkcontext -> type -> type -> Prop :=    (* defn dk_sub *)
 | dks_var : forall (G:dkcontext) (x:tpvar),
      dk_wf_ctx G  ->
      (In  x   G )  ->
     dk_sub G (t_var_f x) (t_var_f x)
 | dks_int : forall (G:dkcontext),
     dk_wf_ctx G ->
     dk_sub G t_int t_int
 | dks_arrow : forall (G:dkcontext) (A1 A2 B1 B2:type),
      dk_sub G B1 A1  ->
     dk_sub G A2 B2 ->
     dk_sub G (t_arrow A1 A2) (t_arrow B1 B2)
 | dks_forall_l : forall (G:dkcontext) (A B C:type),
     dk_wf_tp G C ->
     dk_mono C ->
     dk_sub G  (open_type_wrt_type  A   C )  B ->
     dk_sub G (t_all A) B
 | dks_forall_r : forall (L:vars) (G:dkcontext) (A B:type),
      ( forall x , x \notin  L  -> dk_sub  ( x  ::  G )  A  ( open_type_wrt_type B (t_var_f x) )  )  ->
     dk_sub G A (t_all B).


(** infrastructure *)
Hint Constructors dk_mono dk_wf_ctx dk_wf_tp dk_sub lc_type : core.


